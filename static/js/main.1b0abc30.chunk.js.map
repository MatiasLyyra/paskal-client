{"version":3,"sources":["components/LineCount.tsx","components/CodeField.tsx","util/codeUtil.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["LineCount","props","className","Array","from","lines","keys","map","i","key","CodeField","this","calcRows","code","id","onChange","updateCode","bind","onKeyDown","indentIfTab","rows","Math","max","value","autoCapitalize","autoComplete","autoCorrect","spellCheck","e","onCodeUpdate","target","text","split","filter","c","length","event","targetElement","selectionStart","identation","indentation","keyCode","preventDefault","getModifierState","pos","amount","spacesAdded","firstSplit","substring","secondSplit","lineLength","lastNewLine","lastIndexOf","spacesToAdd","spacesToRemove","deindented","remainder","trimEnd","repeat","indentText","updatedCode","requestAnimationFrame","setSelectionRange","React","PureComponent","App","state","output","error","newCode","setState","axios","post","process","response","data","errorMessage","rel","href","onClick","compile","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1b0abc30.chunk.js","sourcesContent":["import React from 'react';\nimport './LineCount.scss';\n\ntype IProps = {\n  lines: number,\n};\nconst LineCount: React.FC<IProps> = props => (\n  <ul className=\"LineCount-lines\">\n    {Array.from(Array(props.lines).keys()).map(i => (\n      <li key={i}>{i + 1}.</li>\n    ))}\n  </ul>\n);\nexport default LineCount;\n","import React, { KeyboardEvent } from \"react\";\nimport { indentText } from \"../util/codeUtil\";\nimport LineCount from \"./LineCount\";\nimport \"./CodeField.scss\";\n\nexport type IProps = {\n  indentation: number;\n  onCodeUpdate(newCode: string): void;\n  code: string;\n};\nconst TAB_KEY_CODE = 9;\n\nexport class CodeField extends React.PureComponent<IProps> {\n  render() {\n    return (\n      <div className=\"CodeField\">\n        <div className=\"CodeField-LineCount terminal-font\">\n          <LineCount lines={this.calcRows(this.props.code)} />\n        </div>\n        <textarea\n          id=\"rawCode\"\n          className=\"CodeField-code terminal-font\"\n          onChange={this.updateCode.bind(this)}\n          onKeyDown={this.indentIfTab.bind(this)}\n          rows={Math.max(this.calcRows(this.props.code), 5)}\n          value={this.props.code}\n          autoCapitalize=\"false\"\n          autoComplete=\"false\"\n          autoCorrect=\"false\"\n          spellCheck={false}\n        ></textarea>\n      </div>\n    );\n  }\n  updateCode(e: React.ChangeEvent<HTMLTextAreaElement>) {\n    this.props.onCodeUpdate(e.target.value)\n  }\n  calcRows(text: string): number {\n    return text.split(\"\").filter(c => c === \"\\n\").length + 1;\n  }\n  indentIfTab(event: KeyboardEvent<HTMLTextAreaElement>) {\n    const targetElement = event.target as HTMLTextAreaElement;\n    const selectionStart = targetElement.selectionStart;\n    let identation = this.props.indentation;\n    if (event.keyCode === TAB_KEY_CODE) {\n      event.preventDefault();\n      if (event.getModifierState(\"Shift\")) {\n        identation = -identation;\n      }\n      const [updatedCode, spacesAdded] = indentText(\n        this.props.code,\n        selectionStart,\n        identation\n      );\n\n      this.props.onCodeUpdate(updatedCode);\n      requestAnimationFrame(() =>\n        targetElement.setSelectionRange(\n          selectionStart + spacesAdded,\n          selectionStart + spacesAdded\n        )\n      );\n    }\n  }\n}\n\nexport default CodeField;\n","export function indentText(\n  code: string,\n  pos: number,\n  amount: number\n): [string, number] {\n  let spacesAdded = 0;\n  let firstSplit = code.substring(0, pos);\n  const secondSplit = code.substring(pos, code.length);\n\n  let lineLength = firstSplit.length;\n  const lastNewLine = firstSplit.lastIndexOf(\"\\n\");\n  if (lastNewLine !== -1) {\n    lineLength -= lastNewLine + 1;\n    if (lastNewLine + 1 === pos && amount < 0) {\n      return [code, 0];\n    }\n  }\n  let spacesToAdd = lineLength % amount;\n  if (amount < 0) {\n    const spacesToRemove = -amount - spacesToAdd;\n    const deindented = firstSplit.substring(\n      0,\n      Math.max(firstSplit.length - spacesToRemove, lastNewLine + 1)\n    );\n    const remainder = firstSplit\n      .substring(deindented.length, firstSplit.length)\n      .trimEnd();\n    firstSplit = deindented + remainder;\n    spacesAdded = -spacesToRemove + remainder.length;\n  } else {\n    firstSplit += \" \".repeat(amount - spacesToAdd);\n    spacesAdded = amount - spacesToAdd;\n  }\n\n  return [firstSplit + secondSplit, spacesAdded];\n}\n","import React from 'react';\nimport axios from 'axios';\nimport './App.scss';\nimport CodeField from './components/CodeField';\n\ntype IProps = {};\n\ninterface IState {\n  code: string;\n  output: string;\n  error: boolean;\n}\n\nclass App extends React.Component<IProps, IState> {\n  constructor(props: IProps) {\n    super(props);\n    this.state = {\n      code: `program main;\n// Feel free to edit\nvar x,y : integer;\nfunction GCD(x,y: integer): integer\nbegin\n  if y is 0 then\n    gcd := x;\n  else\n    gcd := GCD(y, x % y);\nend\n\nbegin\n  x := 42;\n  y := 12;\n  printf(\n    \"GCD(%d, %d) = %d\",\n    x, y, GCD(x,y)\n  )\nend`,\n      output: '',\n      error: false,\n    };\n  }\n  updateCode(newCode: string) {\n    this.setState({\n      code: newCode,\n    });\n  }\n  async compile() {\n    try {\n      let response = await axios.post(\n        `${process.env.REACT_APP_API_URL}/execute`,\n        this.state.code,\n      );\n      this.setState({\n        output: `> ${response.data}`,\n        error: false,\n      });\n    } catch (error) {\n      let errorMessage = '';\n      if (!error.response) {\n        errorMessage = `Connection to the server refused`;\n      } else {\n        errorMessage = error.response.data;\n      }\n      this.setState({\n        output: `> ${errorMessage}`,\n        error: true,\n      });\n    }\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <h1 className=\"h1 center mt-2 mb-2\">Paskal compiler</h1>\n        <p>\n          Fork{' '}\n          <a\n            rel=\"noopener noreferrer\"\n            target=\"_blank\"\n            href=\"https://github.com/MatiasLyyra/paskal\">\n            me\n          </a>{' '}\n          on github\n        </p>\n        <h2 className=\"h2 mb-1 mt-1\">Editor:</h2>\n        <CodeField\n          code={this.state.code}\n          onCodeUpdate={this.updateCode.bind(this)}\n          indentation={2}\n        />\n        <button\n          onClick={this.compile.bind(this)}\n          className=\"terminal-font mt-1 \">\n          Run\n        </button>\n        <h2 className=\"h2 mb-1 mt-2\">Stdout:</h2>\n        {this.state.error ? (\n          <code className=\"terminal-font error\">{this.state.output}</code>\n        ) : (\n          <code className=\"terminal-font\">{this.state.output}</code>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}